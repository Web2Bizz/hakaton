# План интеграционного тестирования

## Общая информация

**Цель:** Проверить взаимодействие между компонентами, хуками, Redux store, API и реальными пользовательскими сценариями  
**Инструменты:** React Testing Library, Vitest, MSW (Mock Service Worker)  
**Фокус:** Узкие места, потенциальные баги, race conditions, синхронизация состояния

---

## 1. АУТЕНТИФИКАЦИЯ И АВТОРИЗАЦИЯ

### 1.1 Полный цикл аутентификации

#### ✅ Тест: Регистрация → Автоматический вход → Сохранение состояния

**Статус:** Реализован в `src/tests/integration/auth/registration-flow.test.tsx`

**Что тестируем:**

- Интеграция `RegistrationForm` → `authService.register` → `UserContext` → `Redux Persist`
- Автоматический вход после регистрации
- Сохранение токенов в localStorage и Redux
- Обновление пользователя в контексте

**Узкие места:**

- Race condition между сохранением токенов и обновлением пользователя
- Синхронизация между Redux Persist и UserContext
- Восстановление состояния после перезагрузки страницы

**Сценарий:**

```typescript
1. Рендер RegistrationForm с Redux Provider и UserProvider
2. Заполнение формы валидными данными
3. Отправка формы (MSW мок успешного ответа)
4. Проверка:
   - Вызов authService.register с правильными данными
   - Сохранение access_token и refresh_token в localStorage
   - Обновление Redux store (authApi)
   - Обновление UserContext с данными пользователя
   - Автоматический вызов login mutation
   - Редирект на защищенную страницу
5. Симуляция перезагрузки страницы
6. Проверка восстановления состояния из localStorage
```

#### ✅ Тест: Вход → Обновление токена → Защищенные маршруты

**Статус:** Реализован в `src/tests/integration/auth/login-flow.test.tsx`

**Что тестируем:**

- Интеграция `LoginForm` → `baseQueryWithReauth` → `ProtectedRoute`
- Автоматическое обновление токена при 401
- Защита маршрутов на основе состояния пользователя

**Узкие места:**

- Race condition при одновременных запросах с истекшим токеном
- Множественные попытки обновления токена
- Timing между проверкой пользователя и редиректом

**Сценарий:**

```typescript
1. Рендер LoginForm с полным провайдером
2. Вход с валидными credentials
3. Сохранение токенов
4. Выполнение защищенного запроса (MSW возвращает 401)
5. Проверка:
   - Автоматический вызов refresh token
   - Обновление токенов
   - Повтор оригинального запроса с новым токеном
   - Успешное выполнение запроса
6. Рендер ProtectedRoute с неавторизованным пользователем
7. Проверка редиректа на /login
8. Рендер ProtectedRoute с авторизованным пользователем
9. Проверка отображения children
```

#### ✅ Тест: Выход → Очистка состояния → Редирект

**Статус:** Реализован в `src/tests/integration/auth/logout-flow.test.tsx`

**Что тестируем:**

- Интеграция `useAuth.logout` → очистка Redux → очистка UserContext → очистка localStorage

**Узкие места:**

- Неполная очистка состояния (остатки в Redux, но очищен localStorage)
- Race condition между очисткой и редиректом

**Сценарий:**

```typescript
1. Авторизованный пользователь в системе
2. Вызов logout()
3. Проверка:
   - Очистка токенов из localStorage
   - Очистка Redux store (authApi)
   - Очистка UserContext
   - Редирект на главную/логин
   - Невозможность доступа к защищенным маршрутам
```

---

## 2. СОЗДАНИЕ КВЕСТА (КРИТИЧЕСКИЙ ПУТЬ)

### 2.1 Полный цикл создания квеста

#### ✅ Тест: Форма → Валидация → Загрузка изображений → Создание → Обновление пользователя

**Статус:** Реализован в `src/tests/integration/quest/quest-creation-flow.test.tsx` (базовая версия)

**Примечание:** Тест реализован с базовой функциональностью. Для полного теста требуется установка координат через LocationPicker, что требует дополнительной настройки мокирования или прямого доступа к форме. Текущая версия проверяет:

- Заполнение всех обязательных полей формы
- Валидацию формы
- Обработку ошибок загрузки изображений
- Проверку лимита квестов

**Что тестируем:**

- Интеграция `AddQuestForm` → `useQuestForm` → `useQuestSubmission` → `useQuestImageUpload`
- Цепочка: валидация → загрузка изображений → создание квеста → обновление пользователя
- Синхронизация контактов через `useQuestContactSync`

**Узкие места:**

- Порядок операций (изображения должны загрузиться до создания квеста)
- Обработка ошибок загрузки изображений (квест не должен создаваться)
- Обновление пользователя может провалиться (квест уже создан)
- Синхронизация между contacts и curator полями (двусторонняя)
- Валидация лимита квестов перед отправкой

**Сценарий:**

```typescript
1. Рендер AddQuestForm с авторизованным пользователем
2. Заполнение всех обязательных полей
3. Добавление base64 изображения для storyImage
4. Добавление base64 изображений для gallery
5. Выбор местоположения на карте (latitude, longitude)
6. Добавление контактов
7. Проверка синхронизации:
   - Изменение contacts[0].value → curatorName обновляется
   - Изменение curatorName → contacts обновляется
8. Отправка формы
9. Проверка последовательности:
   - Валидация лимита квестов (useGetQuestsQuery)
   - Валидация местоположения
   - Загрузка изображений (MSW мок uploadImages)
   - Преобразование base64 → FormData → blob
   - Создание квеста с загруженными URL (MSW мок createQuest)
   - Обновление пользователя с questId (MSW мок updateUser)
   - Обновление UserContext
   - Вызов onSuccess callback
   - Редирект/навигация
10. Проверка ошибок:
    - Ошибка загрузки изображений → квест не создается
    - Ошибка создания квеста → пользователь не обновляется
    - Ошибка обновления пользователя → квест создан, но пользователь не обновлен
```

#### Тест: Валидация лимита квестов

**Что тестируем:**

- Проверка лимита перед отправкой формы
- Отображение ошибки при превышении лимита

**Узкие места:**

- Race condition: пользователь создает квест, пока другой запрос еще не завершен
- Кэширование данных о квестах пользователя

**Сценарий:**

```typescript
1. Пользователь с максимальным количеством квестов
2. Попытка создать новый квест
3. Проверка:
   - Вызов useGetQuestsQuery
   - Проверка лимита
   - Отображение ошибки
   - Форма не отправляется
```

#### Тест: Загрузка изображений с ошибками

**Что тестируем:**

- Обработка ошибок при загрузке изображений
- Частичная загрузка (одно изображение загрузилось, другое нет)

**Узкие места:**

- Неполная загрузка → квест создается с частичными данными
- Некорректный base64 формат

**Сценарий:**

```typescript
1. Форма с несколькими изображениями
2. MSW мок: первое изображение успешно, второе ошибка
3. Проверка:
   - Ошибка отображается пользователю
   - Квест не создается
   - Частично загруженные изображения не остаются на сервере
```

---

## 3. РЕДАКТИРОВАНИЕ КВЕСТА

### 3.1 Загрузка и обновление данных

#### Тест: Загрузка квеста → Заполнение формы → Обновление → Синхронизация

**Что тестируем:**

- Интеграция `QuestUpdateForm` → `useQuestEditForm` → загрузка данных → трансформация → обновление

**Узкие места:**

- Трансформация данных из API в форму (transformApiResponseToFormData)
- Сохранение существующих изображений vs загрузка новых
- Синхронизация контактов при редактировании
- Обновление этапов и требований

**Сценарий:**

```typescript
1. Рендер QuestUpdateForm с questId
2. Загрузка данных квеста (MSW мок)
3. Проверка заполнения формы:
   - Все поля заполнены корректно
   - Существующие изображения отображаются
   - Этапы загружены
   - Контакты синхронизированы с curator полями
4. Редактирование полей
5. Добавление новых изображений (смешанно: старые URL + новые base64)
6. Отправка формы
7. Проверка:
   - Загружаются только новые изображения (base64)
   - Старые URL остаются без изменений
   - Обновление квеста с правильными данными
   - Трансформация формы в API формат (transformFormDataToUpdateRequest)
```

#### Тест: Удаление квеста → Обновление пользователя

**Что тестируем:**

- Архивация/удаление квеста → удаление questId из пользователя

**Узкие места:**

- Пользователь обновляется, но квест не удаляется (или наоборот)
- Race condition при одновременном удалении

**Сценарий:**

```typescript
1. Квест с questId в пользователе
2. Архивация квеста
3. Проверка:
   - Квест помечен как archived
   - questId удален из пользователя
   - UserContext обновлен
   - Квест не отображается на карте (фильтр archived)
```

---

## 4. КАРТА И ФИЛЬТРАЦИЯ

### 4.1 Загрузка и отображение данных

#### Тест: Загрузка квестов и организаций → Фильтрация → Отображение на карте

**Что тестируем:**

- Интеграция `Map` → `useMapState` → `useGetQuestsQuery` → `useGetOrganizationsQuery` → фильтры → маркеры

**Узкие места:**

- Нормализация данных (type → organizationTypes)
- Синхронизация фильтров между компонентами
- Производительность при большом количестве маркеров
- Кластеризация маркеров
- Исключение archived квестов из фильтрации

**Сценарий:**

```typescript
1. Рендер Map компонента
2. Загрузка данных (MSW моки):
   - Квесты (включая archived)
   - Организации (с разными структурами: type и organizationTypes)
3. Проверка нормализации:
   - Организации с type преобразуются в organizationTypes
   - Archived квесты исключаются из filteredQuests
4. Применение фильтров:
   - По городу
   - По типу организации
   - По виду помощи
   - По поисковому запросу
5. Проверка:
   - filteredQuests и filteredOrganizations обновляются
   - Маркеры на карте обновляются
   - Кластеризация работает корректно
6. Выбор маркера:
   - Открытие MapDetails
   - Отображение правильных данных
```

#### Тест: Поиск на карте → Центрирование → Выбор результата

**Что тестируем:**

- Интеграция `MapSearch` → геокодирование → обновление карты → выбор результата

**Узкие места:**

- Синхронизация searchCenter и searchZoom между компонентами
- Поиск по адресу vs поиск по квестам/организациям
- Очистка поиска при смене фильтров

**Сценарий:**

```typescript
1. Ввод адреса в MapSearch
2. MSW мок геокодирования
3. Проверка:
   - searchCenter обновляется
   - searchZoom устанавливается
   - Карта центрируется
4. Поиск квестов/организаций
5. Выбор результата из списка
6. Проверка:
   - Карта центрируется на выбранном элементе
   - MapDetails открывается с правильными данными
```

#### Тест: Геолокация → Центрирование на пользователе

**Что тестируем:**

- Интеграция `useGeolocation` → `MapControls` → центрирование карты

**Узкие места:**

- Разрешение геолокации
- Ошибки геолокации
- Обновление позиции в реальном времени

**Сценарий:**

```typescript
1. Клик на кнопку "Мое местоположение"
2. Запрос геолокации (мок navigator.geolocation)
3. Проверка:
   - Индикатор загрузки отображается
   - Карта центрируется на координатах пользователя
   - Ошибка геолокации обрабатывается корректно
```

---

## 5. УПРАВЛЕНИЕ ЭТАПАМИ И ТРЕБОВАНИЯМИ

### 5.1 Управление этапами квеста

#### Тест: Добавление этапа → Требования → Обновление прогресса

**Что тестируем:**

- Интеграция `QuestManagement` → управление этапами → требования → API обновления

**Узкие места:**

- Валидация требований (финансы, волонтеры, материалы)
- Обновление прогресса этапа
- Синхронизация между локальным состоянием и API

**Сценарий:**

```typescript
1. Рендер QuestManagement с квестом
2. Добавление нового этапа
3. Настройка требований:
   - Финансовое требование
   - Требование волонтеров
   - Требование материалов
4. Сохранение этапа (MSW мок)
5. Проверка:
   - Этап создан с правильными требованиями
   - Локальное состояние обновлено
   - API вызван с правильными данными
6. Обновление прогресса этапа
7. Проверка синхронизации с API
```

---

## 6. REDUX И RTK QUERY ИНТЕГРАЦИЯ

### 6.1 Кэширование и инвалидация

#### Тест: Создание квеста → Инвалидация кэша → Обновление списка

**Что тестируем:**

- Создание квеста → автоматическая инвалидация кэша → обновление списка квестов

**Узкие места:**

- Правильная инвалидация тегов
- Optimistic updates
- Race condition между созданием и обновлением списка

**Сценарий:**

```typescript
1. Список квестов загружен (кэширован)
2. Создание нового квеста
3. Проверка:
   - Теги инвалидированы (invalidatesTags)
   - Список квестов автоматически обновляется
   - Новый квест появляется в списке
   - Кэш обновлен
```

#### Тест: Optimistic updates при обновлении квеста

**Что тестируем:**

- Optimistic update → откат при ошибке

**Узкие места:**

- UI обновляется до ответа сервера
- Откат при ошибке
- Конфликты при одновременных обновлениях

**Сценарий:**

```typescript
1. Редактирование квеста
2. Optimistic update в UI
3. MSW мок ошибки
4. Проверка:
   - UI откатывается к предыдущему состоянию
   - Ошибка отображается пользователю
   - Кэш не обновлен
```

### 6.2 Обработка ошибок API

#### Тест: Сетевые ошибки → Retry логика → Fallback UI

**Что тестируем:**

- Обработка сетевых ошибок в RTK Query
- Retry механизм
- Отображение ошибок пользователю

**Узкие места:**

- Множественные retry при сетевых ошибках
- Timeout запросов
- Частичные ошибки (одна часть данных загрузилась, другая нет)

**Сценарий:**

```typescript
1. Загрузка данных (MSW мок сетевой ошибки)
2. Проверка:
   - Retry логика работает
   - После N попыток показывается ошибка
   - Fallback UI отображается
   - Пользователь может повторить запрос
```

---

## 7. СИНХРОНИЗАЦИЯ СОСТОЯНИЯ

### 7.1 UserContext и Redux синхронизация

#### Тест: Обновление пользователя → Синхронизация контекста и Redux

**Что тестируем:**

- Обновление пользователя через API → синхронизация UserContext и Redux

**Узкие места:**

- Рассинхронизация между UserContext (localStorage) и Redux
- Обновление в одном месте, но не в другом
- Race condition при одновременных обновлениях

**Сценарий:**

```typescript
1. Пользователь в системе (UserContext + Redux)
2. Обновление пользователя через API
3. Проверка:
   - UserContext обновлен
   - localStorage обновлен
   - Redux store обновлен (если используется)
   - Все компоненты получают обновленные данные
```

### 7.2 Redux Persist восстановление

#### Тест: Перезагрузка страницы → Восстановление состояния

**Что тестируем:**

- Redux Persist восстанавливает состояние из localStorage

**Узкие места:**

- Неполное восстановление состояния
- Устаревшие данные в localStorage
- Конфликты версий

**Сценарий:**

```typescript
1. Состояние приложения сохранено (токены, пользователь)
2. Симуляция перезагрузки страницы
3. Проверка:
   - Redux Persist восстанавливает authApi
   - UserContext восстанавливается из localStorage
   - Пользователь остается авторизованным
   - Защищенные маршруты доступны
```

---

## 8. ФОРМЫ И ВАЛИДАЦИЯ

### 8.1 Комплексная валидация форм

#### Тест: Валидация квеста с зависимыми полями

**Что тестируем:**

- Валидация формы с зависимостями между полями
- Условная валидация (например, местоположение обязательно)

**Узкие места:**

- Валидация не срабатывает при изменении зависимых полей
- Порядок валидации
- Асинхронная валидация

**Сценарий:**

```typescript
1. Форма квеста
2. Заполнение полей без местоположения
3. Попытка отправки
4. Проверка:
   - Ошибка валидации местоположения
   - Форма не отправляется
5. Выбор местоположения на карте
6. Проверка:
   - Ошибка исчезает
   - Форма может быть отправлена
```

### 8.2 Синхронизация контактов

#### Тест: Двусторонняя синхронизация contacts ↔ curator поля

**Что тестируем:**

- `useQuestContactSync` синхронизирует contacts и curator поля в обе стороны

**Узкие места:**

- Бесконечный цикл обновлений
- Потеря данных при синхронизации
- Timing issues при быстрых изменениях

**Сценарий:**

```typescript
1. Форма с contacts и curator полями
2. Изменение contacts[0].value (Куратор)
3. Проверка:
   - curatorName обновляется
   - Нет бесконечного цикла
4. Изменение curatorName
5. Проверка:
   - contacts[0].value обновляется
   - Нет бесконечного цикла
6. Быстрые изменения в обоих полях
7. Проверка отсутствия race conditions
```

---

## 9. ГРАНИЧНЫЕ СЛУЧАИ И БАГИ

### 9.1 Race conditions

#### Тест: Одновременные запросы с истекшим токеном

**Что тестируем:**

- Несколько запросов одновременно получают 401 → только один refresh

**Узкие места:**

- Множественные попытки обновления токена
- Запросы выполняются со старым токеном после обновления

**Сценарий:**

```typescript
1. Токен истек
2. Одновременная отправка 3 запросов
3. Все получают 401
4. Проверка:
   - Только один refresh token запрос
   - Все 3 запроса повторяются с новым токеном
   - Нет дублирования запросов
```

### 9.2 Обработка больших данных

#### Тест: Большое количество квестов/организаций → Производительность фильтрации

**Что тестируем:**

- Фильтрация большого количества данных не блокирует UI

**Узкие места:**

- Медленная фильтрация блокирует рендеринг
- Память при большом количестве маркеров

**Сценарий:**

```typescript
1. Загрузка 1000+ квестов и организаций
2. Применение фильтров
3. Проверка:
   - Фильтрация выполняется быстро (< 100ms)
   - UI не блокируется
   - Маркеры кластеризуются корректно
```

### 9.3 Частичные ошибки

#### Тест: Частичная загрузка данных → Fallback UI

**Что тестируем:**

- Квесты загрузились, организации нет → частичное отображение

**Узкие места:**

- Приложение падает при частичной ошибке
- Нет fallback UI

**Сценарий:**

```typescript
1. MSW мок: квесты успешно, организации ошибка
2. Проверка:
   - Квесты отображаются
   - Ошибка организаций обрабатывается
   - Fallback UI для организаций
   - Приложение не падает
```

---

## 10. ПРИОРИТЕТЫ ТЕСТИРОВАНИЯ

### Критический приоритет (P0) - Баги, блокирующие основную функциональность

1. **Создание квеста** - полный цикл с загрузкой изображений
2. **Аутентификация** - вход, обновление токена, защищенные маршруты
3. **Карта** - загрузка данных, фильтрация, отображение маркеров
4. **Синхронизация состояния** - UserContext ↔ Redux ↔ localStorage

### Высокий приоритет (P1) - Важные функции с потенциальными багами

1. **Редактирование квеста** - загрузка, обновление, синхронизация
2. **Управление этапами** - добавление, требования, прогресс
3. **Фильтрация на карте** - производительность, нормализация данных
4. **Синхронизация контактов** - двусторонняя синхронизация

### Средний приоритет (P2) - Дополнительные проверки

1. **Optimistic updates** - откат при ошибках
2. **Граничные случаи** - большие данные, race conditions
3. **Обработка ошибок** - сетевые ошибки, retry логика

---

## 11. СТРУКТУРА ТЕСТОВЫХ ФАЙЛОВ

```
src/tests/integration/
├── auth/
│   ├── login-flow.test.tsx          # Полный цикл входа
│   ├── registration-flow.test.tsx   # Полный цикл регистрации
│   ├── token-refresh.test.tsx       # Обновление токена
│   └── protected-routes.test.tsx    # Защищенные маршруты
├── quest/
│   ├── quest-creation-flow.test.tsx # Создание квеста (полный цикл)
│   ├── quest-edit-flow.test.tsx     # Редактирование квеста
│   ├── quest-image-upload.test.tsx  # Загрузка изображений
│   ├── quest-contact-sync.test.tsx  # Синхронизация контактов
│   └── quest-limit-validation.test.tsx # Валидация лимита
├── map/
│   ├── map-data-loading.test.tsx    # Загрузка данных на карту
│   ├── map-filtering.test.tsx       # Фильтрация на карте
│   ├── map-search.test.tsx          # Поиск на карте
│   └── map-geolocation.test.tsx     # Геолокация
├── redux/
│   ├── cache-invalidation.test.tsx  # Инвалидация кэша
│   ├── optimistic-updates.test.tsx  # Optimistic updates
│   └── persist-restore.test.tsx     # Восстановление состояния
├── state-sync/
│   ├── user-context-sync.test.tsx   # Синхронизация UserContext
│   └── redux-persist-sync.test.tsx  # Синхронизация Redux Persist
└── utils/
    ├── test-utils.tsx                # Утилиты для тестов
    └── mocks/
        ├── handlers.ts               # MSW handlers
        └── fixtures.ts               # Тестовые данные
```

---

## 12. НАСТРОЙКА ТЕСТОВОГО ОКРУЖЕНИЯ

### Необходимые зависимости

```json
{
	"devDependencies": {
		"@testing-library/react": "^14.0.0",
		"@testing-library/jest-dom": "^6.0.0",
		"@testing-library/user-event": "^14.0.0",
		"msw": "^2.0.0",
		"vitest": "^1.0.0",
		"@vitest/ui": "^1.0.0"
	}
}
```

### Настройка MSW

```typescript
// src/tests/integration/utils/mocks/handlers.ts
import { http, HttpResponse } from 'msw'
import { setupServer } from 'msw/node'

export const handlers = [
	// Auth handlers
	http.post('/v1/auth/login', () => {
		return HttpResponse.json({
			access_token: 'mock-access-token',
			refresh_token: 'mock-refresh-token',
			user: {
				/* mock user */
			},
		})
	}),

	// Quest handlers
	http.post('/v1/quests', () => {
		return HttpResponse.json({
			/* mock quest */
		})
	}),

	// ... другие handlers
]

export const server = setupServer(...handlers)
```

### Test utilities

```typescript
// src/tests/integration/utils/test-utils.tsx
import { render } from '@testing-library/react'
import { Provider } from 'react-redux'
import { setupStore } from '@/store/store'
import { UserProvider } from '@/contexts/UserContext'
import { BrowserRouter } from 'react-router-dom'

export function renderWithProviders(
	ui: React.ReactElement,
	{ preloadedState = {}, store = setupStore().store, ...renderOptions } = {}
) {
	function Wrapper({ children }: { children: React.ReactNode }) {
		return (
			<Provider store={store}>
				<UserProvider>
					<BrowserRouter>{children}</BrowserRouter>
				</UserProvider>
			</Provider>
		)
	}

	return { store, ...render(ui, { wrapper: Wrapper, ...renderOptions }) }
}
```

---

## 13. МЕТРИКИ УСПЕХА

### Покрытие интеграционными тестами

- **Критичные пути:** 100% покрытие
- **Важные функции:** 90%+ покрытие
- **Общее покрытие интеграционными тестами:** 80%+

### Критерии качества

1. Все P0 тесты проходят
2. Нет race conditions в критичных путях
3. Обработка всех типов ошибок
4. Производительность фильтрации < 100ms для 1000+ элементов
5. Восстановление состояния работает корректно

---

## 14. ЧЕКЛИСТ ПЕРЕД НАПИСАНИЕМ ТЕСТОВ

- [ ] Определен scope теста (что именно тестируем)
- [ ] Выявлены узкие места и потенциальные баги
- [ ] Подготовлены MSW handlers для всех API вызовов
- [ ] Подготовлены test utilities (renderWithProviders и т.д.)
- [ ] Определены граничные случаи
- [ ] Подготовлены тестовые данные (fixtures)
- [ ] Определены ожидаемые результаты
- [ ] Учтены race conditions
- [ ] Учтена обработка ошибок

---

## ЗАКЛЮЧЕНИЕ

Этот план интеграционного тестирования фокусируется на:

1. **Реальных пользовательских сценариях** - полные циклы взаимодействия
2. **Узких местах** - race conditions, синхронизация состояния, порядок операций
3. **Потенциальных багах** - частичные ошибки, неполная очистка состояния, рассинхронизация
4. **Интеграции компонентов** - взаимодействие между формами, хуками, Redux, API

Тесты должны быть написаны с использованием React Testing Library, фокусируясь на поведении, а не на реализации, и проверять реальные пользовательские сценарии.
