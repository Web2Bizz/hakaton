name: Build and Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  NODE_VERSION: '20'
  IMAGE_NAME: ${{ secrets.DOCKER_IMAGE_NAME || 'atom-dbro-backend' }}
  REGISTRY_URL: ${{ secrets.DOCKER_REGISTRY_URL }}

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    outputs:
      image-version: ${{ steps.version.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate and prepare environment variables
        id: validate
        run: |
          REGISTRY_URL="${{ env.REGISTRY_URL }}"
          IMAGE_NAME="${{ env.IMAGE_NAME }}"
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã
          if [ -z "$REGISTRY_URL" ]; then
            echo "‚ùå ERROR: REGISTRY_URL is not set or empty"
            exit 1
          fi
          if [ -z "$IMAGE_NAME" ]; then
            echo "‚ùå ERROR: IMAGE_NAME is not set or empty"
            exit 1
          fi
          
          # –£–¥–∞–ª—è–µ–º –ø—Ä–æ—Ç–æ–∫–æ–ª –∏–∑ REGISTRY_URL, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
          REGISTRY_URL="${REGISTRY_URL#http://}"
          REGISTRY_URL="${REGISTRY_URL#https://}"
          REGISTRY_URL="${REGISTRY_URL%/}"
          
          # –£–¥–∞–ª—è–µ–º –ø—Ä–æ–±–µ–ª—ã –≤ –Ω–∞—á–∞–ª–µ –∏ –∫–æ–Ω—Ü–µ
          REGISTRY_URL=$(echo "$REGISTRY_URL" | xargs)
          IMAGE_NAME=$(echo "$IMAGE_NAME" | xargs)
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω–µ –ø—É—Å—Ç—ã –ø–æ—Å–ª–µ –æ—á–∏—Å—Ç–∫–∏
          if [ -z "$REGISTRY_URL" ]; then
            echo "‚ùå ERROR: REGISTRY_URL is empty after cleaning"
            exit 1
          fi
          if [ -z "$IMAGE_NAME" ]; then
            echo "‚ùå ERROR: IMAGE_NAME is empty after cleaning"
            exit 1
          fi
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç REGISTRY_URL (–Ω–µ –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –ø—Ä–æ–±–µ–ª—ã)
          if [[ "$REGISTRY_URL" =~ [[:space:]] ]]; then
            echo "‚ùå ERROR: REGISTRY_URL contains spaces: '$REGISTRY_URL'"
            exit 1
          fi
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç IMAGE_NAME (–¥–æ–ª–∂–µ–Ω —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å Docker naming conventions)
          # Docker image names: lowercase letters, numbers, dots, dashes, underscores
          # Must start and end with alphanumeric character
          if [[ ! "$IMAGE_NAME" =~ ^[a-z0-9]([a-z0-9._-]*[a-z0-9])?$ ]]; then
            echo "‚ùå ERROR: IMAGE_NAME has invalid format: '$IMAGE_NAME'"
            echo "Image name must contain only lowercase letters, numbers, dots, dashes, and underscores"
            echo "Must start and end with alphanumeric character"
            exit 1
          fi
          
          # –í—ã–≤–æ–¥–∏–º –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ (–º–∞—Å–∫–∏—Ä—É–µ–º —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ)
          echo "‚úÖ REGISTRY_URL length: ${#REGISTRY_URL} characters"
          echo "‚úÖ IMAGE_NAME: $IMAGE_NAME"
          
          # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—á–∏—â–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
          echo "registry_url=$REGISTRY_URL" >> $GITHUB_OUTPUT
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT

      - name: Generate image version from date
        id: version
        run: |
          # –§–æ—Ä–º–∞—Ç: YYYY-MM-DD-HHMMSS (UTC)
          VERSION=$(date -u +"%Y-%m-%d-%H%M%S")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üì¶ Image version: $VERSION"
          
          # –í–∞–ª–∏–¥–∞—Ü–∏—è —Ñ–æ—Ä–º–∞—Ç–∞ –≤–µ—Ä—Å–∏–∏
          if [[ ! "$VERSION" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}-[0-9]{6}$ ]]; then
            echo "‚ùå ERROR: Invalid version format: $VERSION"
            exit 1
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ secrets.DOCKER_REGISTRY_USERNAME }}
          password: ${{ secrets.DOCKER_REGISTRY_PASSWORD }}

      - name: Prepare image tags
        id: tags
        run: |
          REGISTRY_URL="${{ env.REGISTRY_URL }}"
          IMAGE_NAME="${{ env.IMAGE_NAME }}"
          VERSION="${{ steps.version.outputs.version }}"
          
          # –£–¥–∞–ª—è–µ–º –ø—Ä–æ—Ç–æ–∫–æ–ª –∏–∑ REGISTRY_URL, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
          REGISTRY_URL="${REGISTRY_URL#http://}"
          REGISTRY_URL="${REGISTRY_URL#https://}"
          REGISTRY_URL="${REGISTRY_URL%/}"
          
          # –£–¥–∞–ª—è–µ–º –ø—Ä–æ–±–µ–ª—ã
          REGISTRY_URL=$(echo "$REGISTRY_URL" | xargs)
          IMAGE_NAME=$(echo "$IMAGE_NAME" | xargs)
          
          # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–≥–∏
          TAG_VERSION="$REGISTRY_URL/$IMAGE_NAME:$VERSION"
          TAG_LATEST="$REGISTRY_URL/$IMAGE_NAME:latest"
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç —Ç–µ–≥–æ–≤ –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º
          echo "üîç Validating image tags..."
          echo "REGISTRY_URL: '$REGISTRY_URL' (length: ${#REGISTRY_URL})"
          echo "IMAGE_NAME: '$IMAGE_NAME' (length: ${#IMAGE_NAME})"
          echo "VERSION: '$VERSION'"
          echo "TAG_VERSION: '$TAG_VERSION'"
          echo "TAG_LATEST: '$TAG_LATEST'"
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–µ–≥–∏ –Ω–µ –ø—É—Å—Ç—ã
          if [ -z "$TAG_VERSION" ] || [ -z "$TAG_LATEST" ]; then
            echo "‚ùå ERROR: One or more tags are empty"
            exit 1
          fi
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–∑–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç (–Ω–µ –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –¥–≤–æ–π–Ω—ã–µ —Å–ª–µ—à–∏ –∏–ª–∏ –ø—Ä–æ–±–µ–ª—ã)
          if [[ "$TAG_VERSION" =~ // ]] || [[ "$TAG_VERSION" =~ [[:space:]] ]]; then
            echo "‚ùå ERROR: Invalid tag format: '$TAG_VERSION'"
            exit 1
          fi
          
          if [[ "$TAG_LATEST" =~ // ]] || [[ "$TAG_LATEST" =~ [[:space:]] ]]; then
            echo "‚ùå ERROR: Invalid tag format: '$TAG_LATEST'"
            exit 1
          fi
          
          # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–≥–∏
          echo "tag_version=$TAG_VERSION" >> $GITHUB_OUTPUT
          echo "tag_latest=$TAG_LATEST" >> $GITHUB_OUTPUT
          echo "registry_url=$REGISTRY_URL" >> $GITHUB_OUTPUT
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ steps.tags.outputs.tag_version }}
            ${{ steps.tags.outputs.tag_latest }}
          cache-from: type=registry,ref=${{ steps.tags.outputs.registry_url }}/${{ steps.tags.outputs.image_name }}:buildcache
          cache-to: type=registry,ref=${{ steps.tags.outputs.registry_url }}/${{ steps.tags.outputs.image_name }}:buildcache,mode=max

      - name: Output image info
        run: |
          echo "‚úÖ Image pushed successfully"
          echo "üì¶ Version tag: ${{ steps.tags.outputs.tag_version }}"
          echo "üì¶ Latest tag: ${{ steps.tags.outputs.tag_latest }}"
          echo "üîó Full image version: ${{ steps.tags.outputs.tag_version }}"
          echo "üîó Full image latest: ${{ steps.tags.outputs.tag_latest }}"

      - name: Cleanup
        if: always()
        run: |
          echo "üßπ Cleaning up Docker resources..."
          docker builder prune -f || true
          echo "‚úÖ Cleanup completed"
  deploy:
    name: Deploy Application
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Deploy application
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} "export REGISTRY_URL='$REGISTRY_URL' REGISTRY_USERNAME='$REGISTRY_USERNAME' REGISTRY_PASSWORD='$REGISTRY_PASSWORD' PROJECT_DIR_VALUE='$PROJECT_DIR_VALUE' CONTAINER_NAME='$CONTAINER_NAME' IMAGE_NAME='$IMAGE_NAME' SERVICE_NAME='$SERVICE_NAME' COMPOSE_PROJECT_NAME='$COMPOSE_PROJECT_NAME' IMAGE_VERSION='$IMAGE_VERSION'; bash -s" << 'REMOTE_SCRIPT'
            set -e
            
            REGISTRY_URL="${REGISTRY_URL}"
            REGISTRY_USERNAME="${REGISTRY_USERNAME}"
            REGISTRY_PASSWORD="${REGISTRY_PASSWORD}"
            IMAGE_NAME="${IMAGE_NAME:-atom-dbro-backend}"
            IMAGE_VERSION="${IMAGE_VERSION:-latest}"
            PROJECT_DIR="$PROJECT_DIR_VALUE"
            CONTAINER_NAME="${CONTAINER_NAME:-atom-dbro-app}"
            SERVICE_NAME="${SERVICE_NAME:-app}"
            COMPOSE_PROJECT_NAME="${COMPOSE_PROJECT_NAME:-}"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è PROJECT_DIR —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞
            if [ -z "$PROJECT_DIR" ]; then
              echo "‚ùå ERROR: PROJECT_DIR is not set"
              exit 1
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ Docker Registry —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã
            if [ -z "$REGISTRY_URL" ]; then
              echo "‚ùå ERROR: REGISTRY_URL is not set"
              exit 1
            fi
            if [ -z "$REGISTRY_USERNAME" ]; then
              echo "‚ùå ERROR: REGISTRY_USERNAME is not set"
              exit 1
            fi
            if [ -z "$REGISTRY_PASSWORD" ]; then
              echo "‚ùå ERROR: REGISTRY_PASSWORD is not set"
              exit 1
            fi
            
            # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º REGISTRY_URL (—É–¥–∞–ª—è–µ–º –ø—Ä–æ—Ç–æ–∫–æ–ª –∏ trailing slash)
            REGISTRY_URL="${REGISTRY_URL#http://}"
            REGISTRY_URL="${REGISTRY_URL#https://}"
            REGISTRY_URL="${REGISTRY_URL%/}"
            REGISTRY_URL=$(echo "$REGISTRY_URL" | xargs)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç –ø–æ—Å–ª–µ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏
            if [ -z "$REGISTRY_URL" ]; then
              echo "‚ùå ERROR: REGISTRY_URL is empty after normalization"
              exit 1
            fi
            
            if [[ "$REGISTRY_URL" =~ [[:space:]] ]] || [[ "$REGISTRY_URL" =~ // ]]; then
              echo "‚ùå ERROR: Invalid REGISTRY_URL format: '$REGISTRY_URL'"
              exit 1
            fi
            
            # –õ–æ–≥–∏–Ω –≤ Docker Registry
            echo "üîê Logging in to Docker Registry: $REGISTRY_URL"
            echo "$REGISTRY_PASSWORD" | docker login "$REGISTRY_URL" -u "$REGISTRY_USERNAME" --password-stdin
            
            # –ü–æ–ª–Ω—ã–π –ø—É—Ç—å –∫ –æ–±—Ä–∞–∑—É
            FULL_IMAGE_NAME="$REGISTRY_URL/$IMAGE_NAME:$IMAGE_VERSION"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç —Ç–µ–≥–∞ –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º
            if [[ "$FULL_IMAGE_NAME" =~ [[:space:]] ]] || [[ "$FULL_IMAGE_NAME" =~ // ]]; then
              echo "‚ùå ERROR: Invalid image tag format: '$FULL_IMAGE_NAME'"
              echo "REGISTRY_URL: '$REGISTRY_URL'"
              echo "IMAGE_NAME: '$IMAGE_NAME'"
              echo "IMAGE_VERSION: '$IMAGE_VERSION'"
              exit 1
            fi
            
            echo "üì¶ Pulling image: $FULL_IMAGE_NAME"
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –æ–±—Ä–∞–∑ –∏–∑ Registry
            if ! docker pull "$FULL_IMAGE_NAME"; then
              echo "‚ùå ERROR: Failed to pull image from Registry: $FULL_IMAGE_NAME"
              exit 1
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±—Ä–∞–∑ –∑–∞–≥—Ä—É–∂–µ–Ω (–∏—Å–ø–æ–ª—å–∑—É–µ–º docker inspect –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏)
            if ! docker inspect "$FULL_IMAGE_NAME" > /dev/null 2>&1; then
              echo "‚ùå ERROR: Image was not pulled successfully: $FULL_IMAGE_NAME"
              echo "Available images:"
              docker images | head -10
              exit 1
            fi
            
            # –¢–µ–≥–∏—Ä—É–µ–º –ª–æ–∫–∞–ª—å–Ω–æ –¥–ª—è docker-compose
            docker tag "$FULL_IMAGE_NAME" "$IMAGE_NAME:latest"
            echo "‚úÖ Image tagged as $IMAGE_NAME:latest"
            
            # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–æ–µ–∫—Ç–∞
            echo "üìÅ Changing to project directory: $PROJECT_DIR"
            cd "$PROJECT_DIR" || {
              echo "‚ùå ERROR: Failed to change to project directory: $PROJECT_DIR"
              exit 1
            }
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ docker-compose.yml —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            if [ ! -f "docker-compose.yml" ]; then
              echo "‚ùå ERROR: docker-compose.yml not found in $PROJECT_DIR"
              echo "Current directory: $(pwd)"
              echo "Files in directory:"
              ls -la || true
              exit 1
            fi
            
            echo "‚úÖ Found docker-compose.yml in $(pwd)"
            
            # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–∞ –ø–µ—Ä–µ–¥ –¥–µ–ø–ª–æ–µ–º
            echo "üßπ Removing old image versions (if any)..."
            docker images "$IMAGE_NAME" --format "{{.Repository}}:{{.Tag}} {{.ID}}" | \
              grep -v "latest" | \
              awk '{print $2}' | \
              xargs -r docker rmi -f || echo "No old image versions to remove"
            
            # –°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Å–µ—Ç–µ–π Docker (–µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É—é—Ç)
            echo "üåê Ensuring Docker networks exist..."
            docker network create atom-external-network 2>/dev/null || echo "Network atom-external-network already exists"
            docker network create atom-internal-network 2>/dev/null || echo "Network atom-internal-network already exists"
            
            # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Ç–æ–ª—å–∫–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å –Ω–æ–≤—ã–º –æ–±—Ä–∞–∑–æ–º
            echo "üîÑ Restarting application container with new image..."
            echo "Working directory: $(pwd)"
            echo "Container name: $CONTAINER_NAME"
            echo "Service name: $SERVICE_NAME"
            echo "Docker image: $IMAGE_NAME:latest"
            
            # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –º—ã –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
            if [ "$(pwd)" != "$PROJECT_DIR" ]; then
              echo "‚ö†Ô∏è Warning: Not in project directory, changing to $PROJECT_DIR"
              cd "$PROJECT_DIR" || exit 1
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ docker-compose.yml —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            COMPOSE_FILE="$PROJECT_DIR/docker-compose.yml"
            if [ ! -f "$COMPOSE_FILE" ]; then
              echo "‚ùå ERROR: docker-compose.yml not found at $COMPOSE_FILE"
              exit 1
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ docker-compose.yml —Å–æ–¥–µ—Ä–∂–∏—Ç —É–∫–∞–∑–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å
            if ! grep -q "^  $SERVICE_NAME:" "$COMPOSE_FILE"; then
              echo "‚ùå ERROR: Service '$SERVICE_NAME' not found in docker-compose.yml"
              echo "Available services:"
              grep -E "^  [a-zA-Z-]+:" "$COMPOSE_FILE" || echo "No services found"
              exit 1
            fi
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è docker-compose
            export DOCKER_IMAGE="$IMAGE_NAME:latest"
            echo "‚úÖ DOCKER_IMAGE environment variable set to: $DOCKER_IMAGE"
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–º—è –ø—Ä–æ–µ–∫—Ç–∞ (—Å—Ç–µ–∫) –¥–ª—è docker-compose, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–æ
            if [ -n "$COMPOSE_PROJECT_NAME" ]; then
              export COMPOSE_PROJECT_NAME="$COMPOSE_PROJECT_NAME"
              echo "‚úÖ COMPOSE_PROJECT_NAME set to: $COMPOSE_PROJECT_NAME"
            else
              echo "‚ÑπÔ∏è COMPOSE_PROJECT_NAME not set, using default (directory name)"
            fi
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏ —É–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (–µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç)
            if docker ps -a --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
              echo "üõë Stopping existing container: $CONTAINER_NAME"
              docker stop "$CONTAINER_NAME" 2>/dev/null || true
              echo "üóëÔ∏è Removing existing container: $CONTAINER_NAME"
              docker rm "$CONTAINER_NAME" 2>/dev/null || true
            else
              echo "‚ÑπÔ∏è Container $CONTAINER_NAME does not exist, will be created"
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±—Ä–∞–∑ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            if ! docker images | grep -q "$IMAGE_NAME.*latest"; then
              echo "‚ùå ERROR: Docker image $IMAGE_NAME:latest not found"
              echo "Available images:"
              docker images | head -10
              exit 1
            fi
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–æ–ª—å–∫–æ —É–∫–∞–∑–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å —Å –Ω–æ–≤—ã–º –æ–±—Ä–∞–∑–æ–º
            # --force-recreate: –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ—Ç –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–∞–∂–µ –µ—Å–ª–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å
            # --no-deps: –Ω–µ –∑–∞–ø—É—Å–∫–∞–µ—Ç –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
            # --pull never: –Ω–µ –ø—ã—Ç–∞–µ—Ç—Å—è —Å–∫–∞—á–∞—Ç—å –æ–±—Ä–∞–∑ (–æ–Ω —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω)
            # -p –∏–ª–∏ --project-name: —è–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º –∏–º—è –ø—Ä–æ–µ–∫—Ç–∞ (—Å—Ç–µ–∫)
            echo "‚ñ∂Ô∏è Starting service '$SERVICE_NAME' with docker compose..."
            
            if [ -n "$COMPOSE_PROJECT_NAME" ]; then
              echo "Command: docker compose -f '$COMPOSE_FILE' -p '$COMPOSE_PROJECT_NAME' up -d --force-recreate --no-deps --pull never '$SERVICE_NAME'"
              docker compose -f "$COMPOSE_FILE" -p "$COMPOSE_PROJECT_NAME" up -d --force-recreate --no-deps --pull never "$SERVICE_NAME"
            else
              echo "Command: docker compose -f '$COMPOSE_FILE' up -d --force-recreate --no-deps --pull never '$SERVICE_NAME'"
              docker compose -f "$COMPOSE_FILE" up -d --force-recreate --no-deps --pull never "$SERVICE_NAME"
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–ø—É—Å—Ç–∏–ª—Å—è
            if ! docker ps --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
              echo "‚ùå ERROR: Container $CONTAINER_NAME failed to start"
              echo "Container status:"
              docker ps -a | grep "$CONTAINER_NAME" || echo "Container not found"
              exit 1
            fi
            
            echo "‚úÖ Container $CONTAINER_NAME started successfully"
            
            # –û–∂–∏–¥–∞–Ω–∏–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
            echo "‚è≥ Waiting for application container to be ready..."
            MAX_CONTAINER_WAIT_ATTEMPTS=30
            CONTAINER_WAIT_ATTEMPT=0
            CONTAINER_READY=false
            
            while [ $CONTAINER_WAIT_ATTEMPT -lt $MAX_CONTAINER_WAIT_ATTEMPTS ]; do
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–ø—É—â–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç
              if docker ps | grep -q "$CONTAINER_NAME" && docker exec "$CONTAINER_NAME" echo "Container is ready" > /dev/null 2>&1; then
                CONTAINER_READY=true
                echo "‚úÖ Container is ready and accepting commands"
                break
              fi
              CONTAINER_WAIT_ATTEMPT=$((CONTAINER_WAIT_ATTEMPT + 1))
              if [ $CONTAINER_WAIT_ATTEMPT -lt $MAX_CONTAINER_WAIT_ATTEMPTS ]; then
                echo "Waiting for container to be ready... ($CONTAINER_WAIT_ATTEMPT/$MAX_CONTAINER_WAIT_ATTEMPTS)"
                sleep 2
              fi
            done
            
            if [ "$CONTAINER_READY" != true ]; then
              echo "‚ùå Application container failed to start or is not ready"
              echo "üìã Container status:"
              docker ps -a | grep "$CONTAINER_NAME" || echo "Container not found"
              echo "üìã Container logs:"
              docker logs "$CONTAINER_NAME" --tail 50 || true
              exit 1
            fi
            
            # –î–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é –≤—Ä–µ–º—è –Ω–∞ –ø–æ–ª–Ω—ã–π –∑–∞–ø—É—Å–∫
            echo "‚è≥ Waiting for application to fully start (10 seconds)..."
            sleep 10
            
            # –û—á–∏—Å—Ç–∫–∞ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö Docker —Ä–µ—Å—É—Ä—Å–æ–≤ (–¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞)
            echo "üßπ Cleaning up unused Docker resources..."
            echo "üìä Disk usage before cleanup:"
            df -h / | tail -1 || true
            
            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
            docker images "$IMAGE_NAME" --format "{{.Repository}}:{{.Tag}} {{.ID}}" | \
              grep -v "latest" | \
              awk '{print $2}' | \
              xargs -r docker rmi -f || true
            
            # –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤ (–±–µ–∑ volumes –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)
            # –£–¥–∞–ª—è–µ—Ç: –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã, –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –æ–±—Ä–∞–∑—ã, build cache, —Å–µ—Ç–∏
            docker system prune -a -f || echo "‚ö†Ô∏è Warning: Some resources could not be cleaned up"
            
            echo "üìä Disk usage after cleanup:"
            df -h / | tail -1 || true
            
            echo "‚úÖ Deployment completed successfully!"
          REMOTE_SCRIPT
        env:
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}
          REGISTRY_URL: ${{ secrets.DOCKER_REGISTRY_URL }}
          REGISTRY_USERNAME: ${{ secrets.DOCKER_REGISTRY_USERNAME }}
          REGISTRY_PASSWORD: ${{ secrets.DOCKER_REGISTRY_PASSWORD }}
          PROJECT_DIR_VALUE: ${{ secrets.DEPLOY_PROJECT_PATH }}
          CONTAINER_NAME: ${{ secrets.DEPLOY_CONTAINER_NAME || 'atom-dbro-app' }}
          SERVICE_NAME: ${{ secrets.DEPLOY_SERVICE_NAME || 'app' }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_VERSION: ${{ needs.build-and-push.outputs.image-version }}
          COMPOSE_PROJECT_NAME: ${{ secrets.DEPLOY_COMPOSE_PROJECT_NAME || '' }}
