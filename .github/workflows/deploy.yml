name: Build and Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  NODE_VERSION: '20'
  IMAGE_NAME: ${{ secrets.DOCKER_IMAGE_NAME || 'atom-dbro-backend' }}

jobs:
  build:
    name: Build and Export Docker Image
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache,mode=max

      - name: Verify image was built
        run: |
          if ! docker images | grep -q "${{ env.IMAGE_NAME }}.*latest"; then
            echo "‚ùå ERROR: Docker image was not built successfully"
            exit 1
          fi
          echo "‚úÖ Docker image built successfully: ${{ env.IMAGE_NAME }}:latest"
          docker images | grep "${{ env.IMAGE_NAME }}"

      - name: Export Docker image to tar.gz
        run: |
          echo "üì¶ Exporting Docker image to tar.gz..."
          docker save ${{ env.IMAGE_NAME }}:latest | gzip > image.tar.gz
          
          echo "üìä Image file info:"
          ls -lh image.tar.gz
          IMAGE_SIZE=$(du -h image.tar.gz | cut -f1)
          echo "Image size: $IMAGE_SIZE"
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —Å–æ–∑–¥–∞–Ω –∏ –Ω–µ –ø—É—Å—Ç–æ–π
          if [ ! -f image.tar.gz ] || [ ! -s image.tar.gz ]; then
            echo "‚ùå ERROR: Failed to export Docker image"
            exit 1
          fi
          
          echo "‚úÖ Docker image exported successfully"

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: image.tar.gz
          retention-days: 1

  transfer:
    name: Transfer Image to Server
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Validate SSH connection
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
            "echo 'SSH connection successful' && hostname"

      - name: Transfer Docker image to server
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          
          echo "üì¶ Transferring Docker image to server..."
          echo "üìä Image file size: $(du -h image.tar.gz | cut -f1)"
          
          # –ü–µ—Ä–µ–¥–∞–µ–º –æ–±—Ä–∞–∑ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
          scp -o StrictHostKeyChecking=no -P "$SSH_PORT" image.tar.gz ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:/tmp/
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
            "if [ -f /tmp/image.tar.gz ]; then echo '‚úÖ Image file transferred successfully'; ls -lh /tmp/image.tar.gz; else echo '‚ùå ERROR: Image file not found on server'; exit 1; fi"
          
          echo "‚úÖ Docker image transferred successfully"
        env:
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}

  deploy:
    name: Deploy Application
    needs: transfer
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Deploy application
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} "export PROJECT_DIR_VALUE='$PROJECT_DIR_VALUE' CONTAINER_NAME='$CONTAINER_NAME' IMAGE_NAME='$IMAGE_NAME' SERVICE_NAME='$SERVICE_NAME' COMPOSE_PROJECT_NAME='$COMPOSE_PROJECT_NAME'; bash -s" << 'REMOTE_SCRIPT'
            set -e
            
            IMAGE_NAME="${IMAGE_NAME:-atom-dbro-backend}"
            PROJECT_DIR="$PROJECT_DIR_VALUE"
            CONTAINER_NAME="${CONTAINER_NAME:-atom-dbro-app}"
            SERVICE_NAME="${SERVICE_NAME:-app}"
            COMPOSE_PROJECT_NAME="${COMPOSE_PROJECT_NAME:-}"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è PROJECT_DIR —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞
            if [ -z "$PROJECT_DIR" ]; then
              echo "‚ùå ERROR: PROJECT_DIR is not set"
              exit 1
            fi
            
            # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–æ–µ–∫—Ç–∞
            echo "üìÅ Changing to project directory: $PROJECT_DIR"
            cd "$PROJECT_DIR" || {
              echo "‚ùå ERROR: Failed to change to project directory: $PROJECT_DIR"
              exit 1
            }
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ docker-compose.yml —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            if [ ! -f "docker-compose.yml" ]; then
              echo "‚ùå ERROR: docker-compose.yml not found in $PROJECT_DIR"
              echo "Current directory: $(pwd)"
              echo "Files in directory:"
              ls -la || true
              exit 1
            fi
            
            echo "‚úÖ Found docker-compose.yml in $(pwd)"
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –æ–±—Ä–∞–∑ –≤ Docker
            echo "üì• Importing Docker image from tar.gz..."
            if [ ! -f /tmp/image.tar.gz ]; then
              echo "‚ùå ERROR: Image file not found: /tmp/image.tar.gz"
              exit 1
            fi
            
            echo "üìä Image file size: $(du -h /tmp/image.tar.gz | cut -f1)"
            docker load -i /tmp/image.tar.gz
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±—Ä–∞–∑ –∑–∞–≥—Ä—É–∂–µ–Ω
            if ! docker images | grep -q "$IMAGE_NAME.*latest"; then
              echo "‚ùå ERROR: Failed to import Docker image"
              exit 1
            fi
            
            echo "‚úÖ Docker image imported successfully"
            
            # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
            rm -f /tmp/image.tar.gz
            echo "üßπ Cleaned up temporary image file"
            
            # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–∞ –ø–µ—Ä–µ–¥ –¥–µ–ø–ª–æ–µ–º
            echo "üßπ Removing old image versions (if any)..."
            docker images "$IMAGE_NAME" --format "{{.Repository}}:{{.Tag}} {{.ID}}" | \
              grep -v "latest" | \
              awk '{print $2}' | \
              xargs -r docker rmi -f || echo "No old image versions to remove"
            
            # –°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Å–µ—Ç–µ–π Docker (–µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É—é—Ç)
            echo "üåê Ensuring Docker networks exist..."
            docker network create atom-external-network 2>/dev/null || echo "Network atom-external-network already exists"
            docker network create atom-internal-network 2>/dev/null || echo "Network atom-internal-network already exists"
            
            # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Ç–æ–ª—å–∫–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å –Ω–æ–≤—ã–º –æ–±—Ä–∞–∑–æ–º
            echo "üîÑ Restarting application container with new image..."
            echo "Working directory: $(pwd)"
            echo "Container name: $CONTAINER_NAME"
            echo "Service name: $SERVICE_NAME"
            echo "Docker image: $IMAGE_NAME:latest"
            
            # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –º—ã –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
            if [ "$(pwd)" != "$PROJECT_DIR" ]; then
              echo "‚ö†Ô∏è Warning: Not in project directory, changing to $PROJECT_DIR"
              cd "$PROJECT_DIR" || exit 1
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ docker-compose.yml —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            COMPOSE_FILE="$PROJECT_DIR/docker-compose.yml"
            if [ ! -f "$COMPOSE_FILE" ]; then
              echo "‚ùå ERROR: docker-compose.yml not found at $COMPOSE_FILE"
              exit 1
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ docker-compose.yml —Å–æ–¥–µ—Ä–∂–∏—Ç —É–∫–∞–∑–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å
            if ! grep -q "^  $SERVICE_NAME:" "$COMPOSE_FILE"; then
              echo "‚ùå ERROR: Service '$SERVICE_NAME' not found in docker-compose.yml"
              echo "Available services:"
              grep -E "^  [a-zA-Z-]+:" "$COMPOSE_FILE" || echo "No services found"
              exit 1
            fi
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è docker-compose
            export DOCKER_IMAGE="$IMAGE_NAME:latest"
            echo "‚úÖ DOCKER_IMAGE environment variable set to: $DOCKER_IMAGE"
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–º—è –ø—Ä–æ–µ–∫—Ç–∞ (—Å—Ç–µ–∫) –¥–ª—è docker-compose, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–æ
            if [ -n "$COMPOSE_PROJECT_NAME" ]; then
              export COMPOSE_PROJECT_NAME="$COMPOSE_PROJECT_NAME"
              echo "‚úÖ COMPOSE_PROJECT_NAME set to: $COMPOSE_PROJECT_NAME"
            else
              echo "‚ÑπÔ∏è COMPOSE_PROJECT_NAME not set, using default (directory name)"
            fi
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏ —É–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (–µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç)
            if docker ps -a --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
              echo "üõë Stopping existing container: $CONTAINER_NAME"
              docker stop "$CONTAINER_NAME" 2>/dev/null || true
              echo "üóëÔ∏è Removing existing container: $CONTAINER_NAME"
              docker rm "$CONTAINER_NAME" 2>/dev/null || true
            else
              echo "‚ÑπÔ∏è Container $CONTAINER_NAME does not exist, will be created"
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±—Ä–∞–∑ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            if ! docker images | grep -q "$IMAGE_NAME.*latest"; then
              echo "‚ùå ERROR: Docker image $IMAGE_NAME:latest not found"
              echo "Available images:"
              docker images | head -10
              exit 1
            fi
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–æ–ª—å–∫–æ —É–∫–∞–∑–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å —Å –Ω–æ–≤—ã–º –æ–±—Ä–∞–∑–æ–º
            # --force-recreate: –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ—Ç –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–∞–∂–µ –µ—Å–ª–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å
            # --no-deps: –Ω–µ –∑–∞–ø—É—Å–∫–∞–µ—Ç –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
            # --pull never: –Ω–µ –ø—ã—Ç–∞–µ—Ç—Å—è —Å–∫–∞—á–∞—Ç—å –æ–±—Ä–∞–∑ (–æ–Ω —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω)
            # -p –∏–ª–∏ --project-name: —è–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º –∏–º—è –ø—Ä–æ–µ–∫—Ç–∞ (—Å—Ç–µ–∫)
            echo "‚ñ∂Ô∏è Starting service '$SERVICE_NAME' with docker compose..."
            
            if [ -n "$COMPOSE_PROJECT_NAME" ]; then
              echo "Command: docker compose -f '$COMPOSE_FILE' -p '$COMPOSE_PROJECT_NAME' up -d --force-recreate --no-deps --pull never '$SERVICE_NAME'"
              docker compose -f "$COMPOSE_FILE" -p "$COMPOSE_PROJECT_NAME" up -d --force-recreate --no-deps --pull never "$SERVICE_NAME"
            else
              echo "Command: docker compose -f '$COMPOSE_FILE' up -d --force-recreate --no-deps --pull never '$SERVICE_NAME'"
              docker compose -f "$COMPOSE_FILE" up -d --force-recreate --no-deps --pull never "$SERVICE_NAME"
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–ø—É—Å—Ç–∏–ª—Å—è
            if ! docker ps --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
              echo "‚ùå ERROR: Container $CONTAINER_NAME failed to start"
              echo "Container status:"
              docker ps -a | grep "$CONTAINER_NAME" || echo "Container not found"
              exit 1
            fi
            
            echo "‚úÖ Container $CONTAINER_NAME started successfully"
            
            # –û–∂–∏–¥–∞–Ω–∏–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
            echo "‚è≥ Waiting for application container to be ready..."
            MAX_CONTAINER_WAIT_ATTEMPTS=30
            CONTAINER_WAIT_ATTEMPT=0
            CONTAINER_READY=false
            
            while [ $CONTAINER_WAIT_ATTEMPT -lt $MAX_CONTAINER_WAIT_ATTEMPTS ]; do
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–ø—É—â–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç
              if docker ps | grep -q "$CONTAINER_NAME" && docker exec "$CONTAINER_NAME" echo "Container is ready" > /dev/null 2>&1; then
                CONTAINER_READY=true
                echo "‚úÖ Container is ready and accepting commands"
                break
              fi
              CONTAINER_WAIT_ATTEMPT=$((CONTAINER_WAIT_ATTEMPT + 1))
              if [ $CONTAINER_WAIT_ATTEMPT -lt $MAX_CONTAINER_WAIT_ATTEMPTS ]; then
                echo "Waiting for container to be ready... ($CONTAINER_WAIT_ATTEMPT/$MAX_CONTAINER_WAIT_ATTEMPTS)"
                sleep 2
              fi
            done
            
            if [ "$CONTAINER_READY" != true ]; then
              echo "‚ùå Application container failed to start or is not ready"
              echo "üìã Container status:"
              docker ps -a | grep "$CONTAINER_NAME" || echo "Container not found"
              echo "üìã Container logs:"
              docker logs "$CONTAINER_NAME" --tail 50 || true
              exit 1
            fi
            
            # –î–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é –≤—Ä–µ–º—è –Ω–∞ –ø–æ–ª–Ω—ã–π –∑–∞–ø—É—Å–∫
            echo "‚è≥ Waiting for application to fully start (10 seconds)..."
            sleep 10
            
            # –û—á–∏—Å—Ç–∫–∞ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö Docker —Ä–µ—Å—É—Ä—Å–æ–≤ (–¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞)
            echo "üßπ Cleaning up unused Docker resources..."
            echo "üìä Disk usage before cleanup:"
            df -h / | tail -1 || true
            
            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
            docker images "$IMAGE_NAME" --format "{{.Repository}}:{{.Tag}} {{.ID}}" | \
              grep -v "latest" | \
              awk '{print $2}' | \
              xargs -r docker rmi -f || true
            
            # –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤ (–±–µ–∑ volumes –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)
            # –£–¥–∞–ª—è–µ—Ç: –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã, –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –æ–±—Ä–∞–∑—ã, build cache, —Å–µ—Ç–∏
            docker system prune -a -f || echo "‚ö†Ô∏è Warning: Some resources could not be cleaned up"
            
            echo "üìä Disk usage after cleanup:"
            df -h / | tail -1 || true
            
            echo "‚úÖ Deployment completed successfully!"
          REMOTE_SCRIPT
        env:
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}
          PROJECT_DIR_VALUE: ${{ secrets.DEPLOY_PROJECT_PATH }}
          CONTAINER_NAME: ${{ secrets.DEPLOY_CONTAINER_NAME || 'atom-dbro-app' }}
          SERVICE_NAME: ${{ secrets.DEPLOY_SERVICE_NAME || 'app' }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          COMPOSE_PROJECT_NAME: ${{ secrets.DEPLOY_COMPOSE_PROJECT_NAME || '' }}
