name: Build and Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  NODE_VERSION: '20'
  IMAGE_NAME: ${{ secrets.DOCKER_IMAGE_NAME || 'atom-dbro-backend' }}

jobs:
  build:
    name: Build and Export Docker Image
    runs-on: ubuntu-latest
    outputs:
      use_remote: ${{ steps.build_target.outputs.use_remote }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine build target
        id: build_target
        shell: bash
        run: |
          echo "üîç Checking build server configuration..."

          # –ï—Å–ª–∏ BUILD_SERVER_HOST —É–∫–∞–∑–∞–Ω - –∏—Å–ø–æ–ª—å–∑—É–µ–º —É–¥–∞–ª—ë–Ω–Ω—É—é —Å–±–æ—Ä–∫—É
          # GitHub –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Å–±–æ—Ä–∫–∏ –∏ –ø–µ—Ä–µ–¥–∞—á–∏
          if [ -n "$BUILD_SERVER_HOST" ]; then
            echo "use_remote=true" >> "$GITHUB_OUTPUT"
            echo "üõ∞Ô∏è  BUILD_SERVER_HOST is set. Using remote build server."
            echo "‚úÖ Output: use_remote=true"
            echo "‚ÑπÔ∏è  GitHub will NOT be used for build or transfer"
          else
            echo "use_remote=false" >> "$GITHUB_OUTPUT"
            echo "üèóÔ∏è  BUILD_SERVER_HOST not set. Using GitHub runner for build."
            echo "‚úÖ Output: use_remote=false"
            echo "‚ÑπÔ∏è  GitHub will be used for build and transfer"
          fi

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ output —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
          echo "üîç Verifying output was set correctly..."
          if [ -f "$GITHUB_OUTPUT" ]; then
            echo "GITHUB_OUTPUT file contents:"
            cat "$GITHUB_OUTPUT" || true
          fi

          # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á—Ç–æ output –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
          OUTPUT_VALUE=$(grep "^use_remote=" "$GITHUB_OUTPUT" 2>/dev/null | cut -d'=' -f2 || echo "")
          if [ -z "$OUTPUT_VALUE" ]; then
            echo "‚ùå ERROR: Failed to set use_remote output!"
            exit 1
          fi
          echo "‚úÖ Confirmed: use_remote=$OUTPUT_VALUE"
        env:
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}

      - name: Set up SSH for build server
        if: steps.build_target.outputs.use_remote == 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.BUILD_SERVER_SSH_KEY }}

      - name: Validate build server connection
        if: steps.build_target.outputs.use_remote == 'true'
        shell: bash
        env:
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}
          BUILD_SERVER_USER: ${{ secrets.BUILD_SERVER_USER }}
          BUILD_SERVER_SSH_PORT: ${{ secrets.BUILD_SERVER_SSH_PORT || '22' }}
        run: |
          ssh -o StrictHostKeyChecking=no -p "$BUILD_SERVER_SSH_PORT" "$BUILD_SERVER_USER@$BUILD_SERVER_HOST" \
            "echo 'SSH connection to build server successful'; hostname"

      - name: Sync source to build server
        if: steps.build_target.outputs.use_remote == 'true'
        shell: bash
        env:
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}
          BUILD_SERVER_USER: ${{ secrets.BUILD_SERVER_USER }}
          BUILD_SERVER_PROJECT_PATH: ${{ secrets.BUILD_SERVER_PROJECT_PATH || '/tmp/atom-dbro-build' }}
          BUILD_SERVER_SSH_PORT: ${{ secrets.BUILD_SERVER_SSH_PORT || '22' }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
          BUILD_SERVER_GIT_SSH_KEY: ${{ secrets.BUILD_SERVER_GIT_SSH_KEY }}
        run: |
          echo "üì¶ Syncing repository to build server via git SSH..."
          echo "Repository: $GITHUB_REPOSITORY"
          echo "Commit: $GITHUB_SHA"
          echo "Path: $BUILD_SERVER_PROJECT_PATH"

          # –ö–æ–¥–∏—Ä—É–µ–º SSH –∫–ª—é—á –≤ base64 –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –ø–µ—Ä–µ–¥–∞—á–∏
          ENCODED_KEY=$(echo "$BUILD_SERVER_GIT_SSH_KEY" | base64 -w 0)

          # –ü–µ—Ä–µ–¥–∞—ë–º SSH –∫–ª—é—á –Ω–∞ build server –∏ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º git –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è SSH
          ssh -o StrictHostKeyChecking=no -p "$BUILD_SERVER_SSH_PORT" "$BUILD_SERVER_USER@$BUILD_SERVER_HOST" \
            BUILD_SERVER_PROJECT_PATH="$BUILD_SERVER_PROJECT_PATH" \
            GITHUB_REPOSITORY="$GITHUB_REPOSITORY" \
            GITHUB_SHA="$GITHUB_SHA" \
            ENCODED_KEY="$ENCODED_KEY" \
            'bash -s' <<'REMOTE_SCRIPT'
          set -euo pipefail

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ git
          if ! command -v git &> /dev/null; then
            echo "‚ùå ERROR: git is not installed on build server"
            echo "Please install git: sudo apt-get install git (Ubuntu/Debian) or sudo yum install git (CentOS/RHEL)"
            exit 1
          fi

          # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º SSH –∫–ª—é—á –¥–ª—è GitHub
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # –î–µ–∫–æ–¥–∏—Ä—É–µ–º –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º SSH –∫–ª—é—á
          echo "$ENCODED_KEY" | base64 -d > ~/.ssh/github_key
          chmod 600 ~/.ssh/github_key

          # –î–æ–±–∞–≤–ª—è–µ–º github.com –≤ known_hosts
          ssh-keyscan -H github.com >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 600 ~/.ssh/known_hosts 2>/dev/null || true

          # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º SSH config –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–ª—é—á–∞
          cat > ~/.ssh/config <<'SSHCONFIG'
          Host github.com
              HostName github.com
              User git
              IdentityFile ~/.ssh/github_key
              StrictHostKeyChecking no
              IdentitiesOnly yes
          SSHCONFIG
          chmod 600 ~/.ssh/config

          REPO_URL="git@github.com:$GITHUB_REPOSITORY.git"

          # –ï—Å–ª–∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ —ç—Ç–æ git —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
          if [ -d "$BUILD_SERVER_PROJECT_PATH/.git" ]; then
            echo "üìÇ Repository exists, updating..."
            cd "$BUILD_SERVER_PROJECT_PATH"
            
            # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ª—é–±—ã–µ –ª–æ–∫–∞–ª—å–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
            git reset --hard
            git clean -fdx
            
            # –û–±–Ω–æ–≤–ª—è–µ–º remote URL –Ω–∞ —Å–ª—É—á–∞–π –µ—Å–ª–∏ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –∏–∑–º–µ–Ω–∏–ª—Å—è
            git remote set-url origin "$REPO_URL"
            
            # Fetch –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
            git fetch origin
            
            # Checkout –Ω—É–∂–Ω–æ–≥–æ –∫–æ–º–º–∏—Ç–∞
            git checkout -f "$GITHUB_SHA"
          else
            echo "üì• Cloning repository..."
            # –£–¥–∞–ª—è–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –µ—Å–ª–∏ –æ–Ω–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –Ω–æ –Ω–µ git —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
            rm -rf "$BUILD_SERVER_PROJECT_PATH"
            
            # –ö–ª–æ–Ω–∏—Ä—É–µ–º —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
            git clone "$REPO_URL" "$BUILD_SERVER_PROJECT_PATH"
            cd "$BUILD_SERVER_PROJECT_PATH"
            
            # Checkout –Ω—É–∂–Ω–æ–≥–æ –∫–æ–º–º–∏—Ç–∞
            git checkout "$GITHUB_SHA"
          fi

          echo "‚úÖ Repository synced successfully"
          echo "Current commit: $(git rev-parse HEAD)"
          echo "üìÅ Project directory contents:"
          ls -la | head -20
          REMOTE_SCRIPT

      - name: Build Docker image on build server
        if: steps.build_target.outputs.use_remote == 'true'
        shell: bash
        env:
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}
          BUILD_SERVER_USER: ${{ secrets.BUILD_SERVER_USER }}
          BUILD_SERVER_PROJECT_PATH: ${{ secrets.BUILD_SERVER_PROJECT_PATH || '/tmp/atom-dbro-build' }}
          BUILD_SERVER_SSH_PORT: ${{ secrets.BUILD_SERVER_SSH_PORT || '22' }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          ENABLE_BUILD_CACHE: ${{ secrets.ENABLE_BUILD_CACHE || 'false' }}
        run: |
          ssh -o StrictHostKeyChecking=no -p "$BUILD_SERVER_SSH_PORT" \
            "$BUILD_SERVER_USER@$BUILD_SERVER_HOST" \
            BUILD_SERVER_PROJECT_PATH="$BUILD_SERVER_PROJECT_PATH" \
            IMAGE_NAME="$IMAGE_NAME" \
            ENABLE_BUILD_CACHE="$ENABLE_BUILD_CACHE" \
            'bash -s' <<'REMOTE_SCRIPT'
          set -euo pipefail
          cd "$BUILD_SERVER_PROJECT_PATH"
          echo "üì¶ Building Docker image $IMAGE_NAME:latest on remote server..."

          # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—É—Ç—å –¥–ª—è –∞—Ä—Ö–∏–≤–∞ –æ–±—Ä–∞–∑–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏–º–µ–Ω–∏ –æ–±—Ä–∞–∑–∞
          REMOTE_IMAGE_PATH="/tmp/${IMAGE_NAME}.tar.gz"

          # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ–ª–∞–≥–∏ –¥–ª—è –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
          if [ "$ENABLE_BUILD_CACHE" = "true" ]; then
            echo "‚úÖ Build cache enabled"
            NO_CACHE_FLAG=""
          else
            echo "üö´ Build cache disabled"
            NO_CACHE_FLAG="--no-cache"
          fi

          if docker buildx version >/dev/null 2>&1; then
            docker buildx build --load -t "$IMAGE_NAME:latest" $NO_CACHE_FLAG -f Dockerfile .
          else
            echo "‚ÑπÔ∏è  docker buildx not available, using docker build."
            docker build -t "$IMAGE_NAME:latest" $NO_CACHE_FLAG -f Dockerfile .
          fi
          echo "üì§ Exporting Docker image archive to $REMOTE_IMAGE_PATH"
          docker save "$IMAGE_NAME:latest" | gzip > "$REMOTE_IMAGE_PATH"
          ls -lh "$REMOTE_IMAGE_PATH"
          REMOTE_SCRIPT

      - name: Validate remote build artifact on build server
        if: steps.build_target.outputs.use_remote == 'true'
        shell: bash
        env:
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}
          BUILD_SERVER_USER: ${{ secrets.BUILD_SERVER_USER }}
          BUILD_SERVER_SSH_PORT: ${{ secrets.BUILD_SERVER_SSH_PORT || '22' }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
          echo "üîç Validating Docker image on build server..."
          REMOTE_IMAGE_PATH="/tmp/${IMAGE_NAME}.tar.gz"
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –æ–±—Ä–∞–∑ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –Ω–∞ build server (–Ω–µ —Å–∫–∞—á–∏–≤–∞–µ–º)
          ssh -o StrictHostKeyChecking=no -p "$BUILD_SERVER_SSH_PORT" \
            "$BUILD_SERVER_USER@$BUILD_SERVER_HOST" \
            "if [ -f '$REMOTE_IMAGE_PATH' ] && [ -s '$REMOTE_IMAGE_PATH' ]; then \
              echo '‚úÖ Docker image exists on build server'; \
              ls -lh '$REMOTE_IMAGE_PATH'; \
            else \
              echo '‚ùå ERROR: Docker image not found or empty on build server'; \
              exit 1; \
            fi"
          echo "‚úÖ Image validation passed - image will be transferred by transfer-scp job"

      - name: Set up Docker Buildx
        if: steps.build_target.outputs.use_remote != 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        if: steps.build_target.outputs.use_remote != 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: ${{ env.IMAGE_NAME }}:latest
          no-cache: ${{ secrets.ENABLE_BUILD_CACHE != 'true' }}
          cache-from: ${{ secrets.ENABLE_BUILD_CACHE == 'true' && 'type=gha' || '' }}
          cache-to: ${{ secrets.ENABLE_BUILD_CACHE == 'true' && 'type=gha,mode=max' || '' }}

      - name: Verify image was built
        if: steps.build_target.outputs.use_remote != 'true'
        run: |
          if ! docker images | grep -q "${{ env.IMAGE_NAME }}.*latest"; then
            echo "‚ùå ERROR: Docker image was not built successfully"
            exit 1
          fi
          echo "‚úÖ Docker image built successfully: ${{ env.IMAGE_NAME }}:latest"
          docker images | grep "${{ env.IMAGE_NAME }}"

      - name: Export Docker image to tar.gz
        if: steps.build_target.outputs.use_remote != 'true'
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
          IMAGE_FILE="${IMAGE_NAME}.tar.gz"
          echo "üì¶ Exporting Docker image to $IMAGE_FILE..."
          docker save ${IMAGE_NAME}:latest | gzip > "$IMAGE_FILE"

          echo "üìä Image file info:"
          ls -lh "$IMAGE_FILE"
          IMAGE_SIZE=$(du -h "$IMAGE_FILE" | cut -f1)
          echo "Image size: $IMAGE_SIZE"

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —Å–æ–∑–¥–∞–Ω –∏ –Ω–µ –ø—É—Å—Ç–æ–π
          if [ ! -f "$IMAGE_FILE" ] || [ ! -s "$IMAGE_FILE" ]; then
            echo "‚ùå ERROR: Failed to export Docker image"
            exit 1
          fi

          echo "‚úÖ Docker image exported successfully"
          echo "IMAGE_FILE=$IMAGE_FILE" >> "$GITHUB_ENV"

      - name: Upload Docker image artifact (local build)
        if: steps.build_target.outputs.use_remote != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: ${{ env.IMAGE_FILE }}
          retention-days: 1

  transfer-github:
    name: Transfer Image via GitHub Artifacts
    needs: build
    runs-on: ubuntu-latest
    if: needs.build.result == 'success'

    steps:
      - name: Check if should run (no build server)
        id: check_mode
        env:
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}
        run: |
          if [ -n "$BUILD_SERVER_HOST" ]; then
            echo "‚è≠Ô∏è BUILD_SERVER_HOST is set, skipping GitHub Artifacts transfer"
            echo "should_run=false" >> "$GITHUB_OUTPUT"
            exit 0
          else
            echo "‚úÖ BUILD_SERVER_HOST is not set, using GitHub Artifacts for transfer"
            echo "should_run=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Verify build mode
        if: steps.check_mode.outputs.should_run == 'true'
        run: |
          echo "üîç Transfer GitHub Job - Build mode verification:"
          echo "‚úÖ Verification passed: Using GitHub Artifacts for transfer"

      - name: Download Docker image artifact
        if: steps.check_mode.outputs.should_run == 'true'
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: ./

      - name: Set up SSH
        if: steps.check_mode.outputs.should_run == 'true'
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Transfer Docker image to server
        if: steps.check_mode.outputs.should_run == 'true'
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}
        run: |
          IMAGE_FILE="${IMAGE_NAME}.tar.gz"
          DEPLOY_IMAGE_PATH="/tmp/${IMAGE_FILE}"

          echo "üì¶ Transferring Docker image via GitHub Artifacts..."
          echo "üìä Image file size: $(du -h "$IMAGE_FILE" | cut -f1)"

          # –ü–µ—Ä–µ–¥–∞–µ–º –æ–±—Ä–∞–∑ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
          scp -o StrictHostKeyChecking=no -P "$DEPLOY_SSH_PORT" "$IMAGE_FILE" "$DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_IMAGE_PATH"

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω
          ssh -o StrictHostKeyChecking=no -p "$DEPLOY_SSH_PORT" "$DEPLOY_USER@$DEPLOY_HOST" \
            "if [ -f '$DEPLOY_IMAGE_PATH' ]; then echo '‚úÖ Image file transferred successfully'; ls -lh '$DEPLOY_IMAGE_PATH'; else echo '‚ùå ERROR: Image file not found on server'; exit 1; fi"

          echo "‚úÖ Docker image transferred successfully"
          echo "DEPLOY_IMAGE_PATH=$DEPLOY_IMAGE_PATH" >> "$GITHUB_ENV"

  transfer-scp:
    name: Transfer Image via SCP (Remote Build)
    needs: build
    runs-on: ubuntu-latest
    if: needs.build.result == 'success'

    steps:
      - name: Check if should run (build server configured)
        id: check_mode
        env:
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}
        run: |
          if [ -z "$BUILD_SERVER_HOST" ]; then
            echo "‚è≠Ô∏è BUILD_SERVER_HOST is not set, skipping SCP transfer"
            echo "should_run=false" >> "$GITHUB_OUTPUT"
            exit 0
          else
            echo "‚úÖ BUILD_SERVER_HOST is set, using SCP for transfer from build server"
            echo "should_run=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Verify build mode
        if: steps.check_mode.outputs.should_run == 'true'
        run: |
          echo "üîç Transfer SCP Job - Build mode verification:"
          echo "‚úÖ Verification passed: Using SCP for transfer from build server"

      - name: Set up SSH keys and config
        if: steps.check_mode.outputs.should_run == 'true'
        env:
          BUILD_SERVER_SSH_KEY: ${{ secrets.BUILD_SERVER_SSH_KEY }}
          DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
          BUILD_SERVER_HOST: ${{ secrets.BUILD_SERVER_HOST }}
          BUILD_SERVER_USER: ${{ secrets.BUILD_SERVER_USER }}
          BUILD_SERVER_SSH_PORT: ${{ secrets.BUILD_SERVER_SSH_PORT || '22' }}
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}
        run: |
          echo "üîë Setting up SSH keys and config..."

          # –°–æ–∑–¥–∞—ë–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è SSH
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–ª—é—á–∏
          echo "$BUILD_SERVER_SSH_KEY" > ~/.ssh/build_server_key
          chmod 600 ~/.ssh/build_server_key

          echo "$DEPLOY_SSH_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # –°–æ–∑–¥–∞—ë–º SSH config
          cat > ~/.ssh/config <<EOF
          Host build-server
              HostName $BUILD_SERVER_HOST
              User $BUILD_SERVER_USER
              Port $BUILD_SERVER_SSH_PORT
              IdentityFile ~/.ssh/build_server_key
              StrictHostKeyChecking no
              UserKnownHostsFile /dev/null

          Host deploy-server
              HostName $DEPLOY_HOST
              User $DEPLOY_USER
              Port $DEPLOY_SSH_PORT
              IdentityFile ~/.ssh/deploy_key
              StrictHostKeyChecking no
              UserKnownHostsFile /dev/null
          EOF
          chmod 600 ~/.ssh/config

          echo "‚úÖ SSH keys and config set up successfully"

          # –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ build server
          echo "üîç Testing connection to build server..."
          ssh build-server "echo 'Build server connection successful'" || {
            echo "‚ùå ERROR: Failed to connect to build server"
            exit 1
          }

          # –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ deploy server
          echo "üîç Testing connection to deploy server..."
          ssh deploy-server "echo 'Deploy server connection successful'" || {
            echo "‚ùå ERROR: Failed to connect to deploy server"
            exit 1
          }

      - name: Transfer image from build server to deploy server
        if: steps.check_mode.outputs.should_run == 'true'
        env:
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
        run: |
          IMAGE_FILE="${IMAGE_NAME}.tar.gz"
          REMOTE_IMAGE_PATH="/tmp/${IMAGE_FILE}"
          DEPLOY_IMAGE_PATH="/tmp/${IMAGE_FILE}"

          echo "üì¶ Transferring Docker image from build server to deploy server via SCP..."

          # –°–∫–∞—á–∏–≤–∞–µ–º –æ–±—Ä–∞–∑ —Å build —Å–µ—Ä–≤–µ—Ä–∞ –≤–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
          scp build-server:"$REMOTE_IMAGE_PATH" "./$IMAGE_FILE"

          echo "üìä Image file size: $(du -h "$IMAGE_FILE" | cut -f1)"

          # –ü–µ—Ä–µ–¥–∞–µ–º –æ–±—Ä–∞–∑ –Ω–∞ deploy —Å–µ—Ä–≤–µ—Ä
          scp "$IMAGE_FILE" deploy-server:"$DEPLOY_IMAGE_PATH"

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω
          ssh deploy-server \
            "if [ -f '$DEPLOY_IMAGE_PATH' ]; then echo '‚úÖ Image transferred successfully'; ls -lh '$DEPLOY_IMAGE_PATH'; else echo '‚ùå ERROR: Image not found'; exit 1; fi"

          echo "‚úÖ Docker image transferred from build server to deploy server successfully"

          # –û—á–∏—â–∞–µ–º –æ–±—Ä–∞–∑ —Å build —Å–µ—Ä–≤–µ—Ä–∞ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –ø–µ—Ä–µ–¥–∞—á–∏
          echo "üßπ Cleaning up image from build server..."
          ssh build-server "rm -f '$REMOTE_IMAGE_PATH' && echo '‚úÖ Cleanup completed'"

          # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—É—Ç—å –¥–ª—è deploy job
          echo "DEPLOY_IMAGE_PATH=$DEPLOY_IMAGE_PATH" >> "$GITHUB_ENV"

  deploy:
    name: Deploy Application
    needs: [build, transfer-github, transfer-scp]
    runs-on: ubuntu-latest
    if: |
      github.ref == 'refs/heads/main' &&
      always() &&
      needs.build.result == 'success' &&
      (needs.transfer-github.result == 'success' || needs.transfer-github.result == 'skipped') &&
      (needs.transfer-scp.result == 'success' || needs.transfer-scp.result == 'skipped')

    steps:
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Deploy application
        run: |
          SSH_PORT="${DEPLOY_SSH_PORT:-22}"
          ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} "export PROJECT_DIR_VALUE='$PROJECT_DIR_VALUE' CONTAINER_NAME='$CONTAINER_NAME' IMAGE_NAME='$IMAGE_NAME' SERVICE_NAME='$SERVICE_NAME' COMPOSE_PROJECT_NAME='$COMPOSE_PROJECT_NAME' RUN_MIGRATIONS='$RUN_MIGRATIONS'; bash -s" << 'REMOTE_SCRIPT'
            set -e
            
            IMAGE_NAME="${IMAGE_NAME:-atom-dbro-backend}"
            PROJECT_DIR="$PROJECT_DIR_VALUE"
            CONTAINER_NAME="${CONTAINER_NAME:-atom-dbro-app}"
            SERVICE_NAME="${SERVICE_NAME:-app}"
            COMPOSE_PROJECT_NAME="${COMPOSE_PROJECT_NAME:-}"
            RUN_MIGRATIONS="${RUN_MIGRATIONS:-false}"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è PROJECT_DIR —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞
            if [ -z "$PROJECT_DIR" ]; then
              echo "‚ùå ERROR: PROJECT_DIR is not set"
              exit 1
            fi
            
            # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–æ–µ–∫—Ç–∞
            echo "üìÅ Changing to project directory: $PROJECT_DIR"
            cd "$PROJECT_DIR" || {
              echo "‚ùå ERROR: Failed to change to project directory: $PROJECT_DIR"
              exit 1
            }
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ docker-compose.yml —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            if [ ! -f "docker-compose.yml" ]; then
              echo "‚ùå ERROR: docker-compose.yml not found in $PROJECT_DIR"
              echo "Current directory: $(pwd)"
              echo "Files in directory:"
              ls -la || true
              exit 1
            fi
            
            echo "‚úÖ Found docker-compose.yml in $(pwd)"
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É –æ–±—Ä–∞–∑–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏–º–µ–Ω–∏ –æ–±—Ä–∞–∑–∞
            IMAGE_FILE="${IMAGE_NAME}.tar.gz"
            DEPLOY_IMAGE_PATH="/tmp/${IMAGE_FILE}"
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –æ–±—Ä–∞–∑ –≤ Docker
            echo "üì• Importing Docker image from $DEPLOY_IMAGE_PATH..."
            if [ ! -f "$DEPLOY_IMAGE_PATH" ]; then
              echo "‚ùå ERROR: Image file not found: $DEPLOY_IMAGE_PATH"
              exit 1
            fi
            
            echo "üìä Image file size: $(du -h "$DEPLOY_IMAGE_PATH" | cut -f1)"
            docker load -i "$DEPLOY_IMAGE_PATH"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±—Ä–∞–∑ –∑–∞–≥—Ä—É–∂–µ–Ω
            if ! docker images | grep -q "$IMAGE_NAME.*latest"; then
              echo "‚ùå ERROR: Failed to import Docker image"
              exit 1
            fi
            
            echo "‚úÖ Docker image imported successfully"
            
            # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
            rm -f "$DEPLOY_IMAGE_PATH"
            echo "üßπ Cleaned up temporary image file: $DEPLOY_IMAGE_PATH"
            
            # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–∞ –ø–µ—Ä–µ–¥ –¥–µ–ø–ª–æ–µ–º
            echo "üßπ Removing old image versions (if any)..."
            docker images "$IMAGE_NAME" --format "{{.Repository}}:{{.Tag}} {{.ID}}" | \
              grep -v "latest" | \
              awk '{print $2}' | \
              xargs -r docker rmi -f || echo "No old image versions to remove"
            
            # –°–æ–∑–¥–∞–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Å–µ—Ç–µ–π Docker (–µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É—é—Ç)
            echo "üåê Ensuring Docker networks exist..."
            docker network create atom-external-network 2>/dev/null || echo "Network atom-external-network already exists"
            docker network create atom-internal-network 2>/dev/null || echo "Network atom-internal-network already exists"
            
            # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Ç–æ–ª—å–∫–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å –Ω–æ–≤—ã–º –æ–±—Ä–∞–∑–æ–º
            echo "üîÑ Restarting application container with new image..."
            echo "Working directory: $(pwd)"
            echo "Container name: $CONTAINER_NAME"
            echo "Service name: $SERVICE_NAME"
            echo "Docker image: $IMAGE_NAME:latest"
            
            # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –º—ã –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
            if [ "$(pwd)" != "$PROJECT_DIR" ]; then
              echo "‚ö†Ô∏è Warning: Not in project directory, changing to $PROJECT_DIR"
              cd "$PROJECT_DIR" || exit 1
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ docker-compose.yml —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            COMPOSE_FILE="$PROJECT_DIR/docker-compose.yml"
            if [ ! -f "$COMPOSE_FILE" ]; then
              echo "‚ùå ERROR: docker-compose.yml not found at $COMPOSE_FILE"
              exit 1
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ docker-compose.yml —Å–æ–¥–µ—Ä–∂–∏—Ç —É–∫–∞–∑–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å
            if ! grep -q "^  $SERVICE_NAME:" "$COMPOSE_FILE"; then
              echo "‚ùå ERROR: Service '$SERVICE_NAME' not found in docker-compose.yml"
              echo "Available services:"
              grep -E "^  [a-zA-Z-]+:" "$COMPOSE_FILE" || echo "No services found"
              exit 1
            fi
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è docker-compose
            export DOCKER_IMAGE="$IMAGE_NAME:latest"
            echo "‚úÖ DOCKER_IMAGE environment variable set to: $DOCKER_IMAGE"
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–º—è –ø—Ä–æ–µ–∫—Ç–∞ (—Å—Ç–µ–∫) –¥–ª—è docker-compose, –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–æ
            if [ -n "$COMPOSE_PROJECT_NAME" ]; then
              export COMPOSE_PROJECT_NAME="$COMPOSE_PROJECT_NAME"
              echo "‚úÖ COMPOSE_PROJECT_NAME set to: $COMPOSE_PROJECT_NAME"
            else
              echo "‚ÑπÔ∏è COMPOSE_PROJECT_NAME not set, using default (directory name)"
            fi
            
            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏ —É–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (–µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç)
            if docker ps -a --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
              echo "üõë Stopping existing container: $CONTAINER_NAME"
              docker stop "$CONTAINER_NAME" 2>/dev/null || true
              echo "üóëÔ∏è Removing existing container: $CONTAINER_NAME"
              docker rm "$CONTAINER_NAME" 2>/dev/null || true
            else
              echo "‚ÑπÔ∏è Container $CONTAINER_NAME does not exist, will be created"
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ–±—Ä–∞–∑ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            if ! docker images | grep -q "$IMAGE_NAME.*latest"; then
              echo "‚ùå ERROR: Docker image $IMAGE_NAME:latest not found"
              echo "Available images:"
              docker images | head -10
              exit 1
            fi
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–æ–ª—å–∫–æ —É–∫–∞–∑–∞–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å —Å –Ω–æ–≤—ã–º –æ–±—Ä–∞–∑–æ–º
            # --force-recreate: –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ—Ç –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–∞–∂–µ –µ—Å–ª–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å
            # --no-deps: –Ω–µ –∑–∞–ø—É—Å–∫–∞–µ—Ç –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
            # --pull never: –Ω–µ –ø—ã—Ç–∞–µ—Ç—Å—è —Å–∫–∞—á–∞—Ç—å –æ–±—Ä–∞–∑ (–æ–Ω —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω)
            # -p –∏–ª–∏ --project-name: —è–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º –∏–º—è –ø—Ä–æ–µ–∫—Ç–∞ (—Å—Ç–µ–∫)
            echo "‚ñ∂Ô∏è Starting service '$SERVICE_NAME' with docker compose..."
            
            if [ -n "$COMPOSE_PROJECT_NAME" ]; then
              echo "Command: docker compose -f '$COMPOSE_FILE' -p '$COMPOSE_PROJECT_NAME' up -d --force-recreate --no-deps --pull never '$SERVICE_NAME'"
              docker compose -f "$COMPOSE_FILE" -p "$COMPOSE_PROJECT_NAME" up -d --force-recreate --no-deps --pull never "$SERVICE_NAME"
            else
              echo "Command: docker compose -f '$COMPOSE_FILE' up -d --force-recreate --no-deps --pull never '$SERVICE_NAME'"
              docker compose -f "$COMPOSE_FILE" up -d --force-recreate --no-deps --pull never "$SERVICE_NAME"
            fi
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–ø—É—Å—Ç–∏–ª—Å—è
            if ! docker ps --format "{{.Names}}" | grep -q "^${CONTAINER_NAME}$"; then
              echo "‚ùå ERROR: Container $CONTAINER_NAME failed to start"
              echo "Container status:"
              docker ps -a | grep "$CONTAINER_NAME" || echo "Container not found"
              exit 1
            fi
            
            echo "‚úÖ Container $CONTAINER_NAME started successfully"
            
            # –û–∂–∏–¥–∞–Ω–∏–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
            echo "‚è≥ Waiting for application container to be ready..."
            MAX_CONTAINER_WAIT_ATTEMPTS=30
            CONTAINER_WAIT_ATTEMPT=0
            CONTAINER_READY=false
            
            while [ $CONTAINER_WAIT_ATTEMPT -lt $MAX_CONTAINER_WAIT_ATTEMPTS ]; do
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–ø—É—â–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç
              if docker ps | grep -q "$CONTAINER_NAME" && docker exec "$CONTAINER_NAME" echo "Container is ready" > /dev/null 2>&1; then
                CONTAINER_READY=true
                echo "‚úÖ Container is ready and accepting commands"
                break
              fi
              CONTAINER_WAIT_ATTEMPT=$((CONTAINER_WAIT_ATTEMPT + 1))
              if [ $CONTAINER_WAIT_ATTEMPT -lt $MAX_CONTAINER_WAIT_ATTEMPTS ]; then
                echo "Waiting for container to be ready... ($CONTAINER_WAIT_ATTEMPT/$MAX_CONTAINER_WAIT_ATTEMPTS)"
                sleep 2
              fi
            done
            
            if [ "$CONTAINER_READY" != true ]; then
              echo "‚ùå Application container failed to start or is not ready"
              echo "üìã Container status:"
              docker ps -a | grep "$CONTAINER_NAME" || echo "Container not found"
              echo "üìã Container logs:"
              docker logs "$CONTAINER_NAME" --tail 50 || true
              exit 1
            fi
            
            # –î–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—é –≤—Ä–µ–º—è –Ω–∞ –ø–æ–ª–Ω—ã–π –∑–∞–ø—É—Å–∫
            echo "‚è≥ Waiting for application to fully start (10 seconds)..."
            sleep 10
            
            # –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–∏–≥—Ä–∞—Ü–∏–π –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ)
            if [ "$RUN_MIGRATIONS" = "true" ]; then
              echo "üóÑÔ∏è Running database migrations..."
              MAX_MIGRATION_ATTEMPTS=3
              MIGRATION_ATTEMPT=0
              MIGRATION_SUCCESS=false
              
              while [ $MIGRATION_ATTEMPT -lt $MAX_MIGRATION_ATTEMPTS ]; do
                # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤—Å–µ—Ö –º–∏–≥—Ä–∞—Ü–∏–π
                # –û–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç —É–∂–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–Ω—ã–µ –º–∏–≥—Ä–∞—Ü–∏–∏ –∏ –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–µ–Ω
                if docker exec "$CONTAINER_NAME" npm run db:apply-all 2>&1; then
                  MIGRATION_SUCCESS=true
                  echo "‚úÖ Database migrations completed successfully"
                  break
                else
                  MIGRATION_ATTEMPT=$((MIGRATION_ATTEMPT + 1))
                  if [ $MIGRATION_ATTEMPT -lt $MAX_MIGRATION_ATTEMPTS ]; then
                    echo "‚ö†Ô∏è Migration attempt $MIGRATION_ATTEMPT failed, retrying in 5 seconds..."
                    echo "üìã Recent container logs:"
                    docker logs "$CONTAINER_NAME" --tail 20 2>&1 | tail -5 || true
                    sleep 5
                  else
                    echo "‚ö†Ô∏è Custom migration script failed after $MAX_MIGRATION_ATTEMPTS attempts"
                    echo "‚ö†Ô∏è WARNING: Using drizzle-kit migrate as fallback - this may cause issues if migrations were partially applied"
                    echo "‚ö†Ô∏è Trying drizzle-kit migrate as fallback..."
                    # Fallback –Ω–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –∫–æ–º–∞–Ω–¥—É drizzle-kit migrate
                    # –í–ù–ò–ú–ê–ù–ò–ï: drizzle-kit migrate –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, –∫–∞–∫–∏–µ –º–∏–≥—Ä–∞—Ü–∏–∏ —É–∂–µ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã
                    if docker exec "$CONTAINER_NAME" npm run db:migrate 2>&1; then
                      MIGRATION_SUCCESS=true
                      echo "‚úÖ Database migrations completed successfully (using drizzle-kit migrate)"
                      break
                    else
                      echo "‚ùå Database migrations failed after $MAX_MIGRATION_ATTEMPTS attempts (both methods)"
                      echo "üìã Container logs:"
                      docker logs "$CONTAINER_NAME" --tail 50 || true
                      exit 1
                    fi
                  fi
                fi
              done
              
              if [ "$MIGRATION_SUCCESS" != true ]; then
                echo "‚ùå Failed to apply database migrations"
                exit 1
              fi
            else
              echo "‚ÑπÔ∏è Database migrations skipped (RUN_MIGRATIONS not set to 'true')"
            fi
            
            # –û—á–∏—Å—Ç–∫–∞ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö Docker —Ä–µ—Å—É—Ä—Å–æ–≤ (–¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞)
            echo "üßπ Cleaning up unused Docker resources..."
            echo "üìä Disk usage before cleanup:"
            df -h / | tail -1 || true
            
            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –≤–µ—Ä—Å–∏–∏ –æ–±—Ä–∞–∑–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
            docker images "$IMAGE_NAME" --format "{{.Repository}}:{{.Tag}} {{.ID}}" | \
              grep -v "latest" | \
              awk '{print $2}' | \
              xargs -r docker rmi -f || true
            
            # –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤ (–±–µ–∑ volumes –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)
            # –£–¥–∞–ª—è–µ—Ç: –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã, –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –æ–±—Ä–∞–∑—ã, build cache, —Å–µ—Ç–∏
            docker system prune -a -f || echo "‚ö†Ô∏è Warning: Some resources could not be cleaned up"
            
            echo "üìä Disk usage after cleanup:"
            df -h / | tail -1 || true
            
            echo "‚úÖ Deployment completed successfully!"
          REMOTE_SCRIPT
        env:
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT || '22' }}
          PROJECT_DIR_VALUE: ${{ secrets.DEPLOY_PROJECT_PATH }}
          CONTAINER_NAME: ${{ secrets.DEPLOY_CONTAINER_NAME || 'atom-dbro-app' }}
          SERVICE_NAME: ${{ secrets.DEPLOY_SERVICE_NAME || 'app' }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          COMPOSE_PROJECT_NAME: ${{ secrets.DEPLOY_COMPOSE_PROJECT_NAME || '' }}
          RUN_MIGRATIONS: ${{ secrets.RUN_MIGRATIONS || 'false' }}
